/*
   Copyright 2013-2015 Heterogeneous System Architecture (HSA) Foundation

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#ifndef INCLUDED_HSAIL_TESTGEN_BRIG_CONTEXT_H
#define INCLUDED_HSAIL_TESTGEN_BRIG_CONTEXT_H

#include "HSAILBrigantine.h"
#include "HSAILItems.h"
#include "HSAILSRef.h"
#include "Brig.h"

#include <string>
#include <sstream>

using std::string;

using HSAIL_ASM::Brigantine;
using HSAIL_ASM::BrigContainer;

using HSAIL_ASM::Code;
using HSAIL_ASM::Directive;
using HSAIL_ASM::DirectiveKernel;
using HSAIL_ASM::DirectiveFunction;
using HSAIL_ASM::DirectiveIndirectFunction;
using HSAIL_ASM::DirectiveSignature;
using HSAIL_ASM::DirectiveExecutable;
using HSAIL_ASM::DirectiveVariable;
using HSAIL_ASM::DirectiveFbarrier;
using HSAIL_ASM::DirectiveLabel;
using HSAIL_ASM::Inst;
using HSAIL_ASM::Operand;
using HSAIL_ASM::OperandRegister;
using HSAIL_ASM::OperandAddress;
using HSAIL_ASM::SRef;
using HSAIL_ASM::OperandConstantBytes;
using HSAIL_ASM::ArbitraryData;

using HSAIL_ASM::getNaturalAlignment;
using HSAIL_ASM::elementType2arrayType;
using HSAIL_ASM::isArrayType;

namespace TESTGEN {

// ============================================================================
// ============================================================================
// ============================================================================
// Context used for BRIG generation.
// Context includes the following components:
// - BRIG container;
// - TestGen-specific options

class BrigSettings
{
private:
    static unsigned  brigModel;
    static unsigned  brigProfile;
    static bool      brigComments;
    static bool      stdSubset;
    static bool      imgSubset;
    static bool      gcnSubset;

public:
    static void init(unsigned model, unsigned profile, bool stdInst, bool imgInst, bool gcnInst, bool commentsEnabled)
    {
        assert(model == BRIG_MACHINE_SMALL  || model == BRIG_MACHINE_LARGE);
        assert(profile == BRIG_PROFILE_BASE || profile == BRIG_PROFILE_FULL);

        brigModel    = model;
        brigProfile  = profile;
        brigComments = commentsEnabled;

        stdSubset = stdInst;
        imgSubset = imgInst;
        gcnSubset = gcnInst;
    }

    static unsigned getModel()     { assert(brigModel != BRIG_MACHINE_UNDEF); return brigModel; }
    static bool     isSmallModel() { return getModel() == BRIG_MACHINE_SMALL; }
    static bool     isLargeModel() { return getModel() == BRIG_MACHINE_LARGE; }
    static unsigned getModelType() { return isSmallModel() ? BRIG_TYPE_U32 : BRIG_TYPE_U64; }
    static unsigned getModelSize() { return isSmallModel() ? 32 : 64; }

    static unsigned getProfile()   { assert(brigProfile != BRIG_PROFILE_UNDEF); return brigProfile; }
    static bool     isFullProfile(){ return getProfile() == BRIG_PROFILE_FULL; }
    static bool     isBaseProfile(){ return getProfile() == BRIG_PROFILE_BASE; }

    static bool     commentsEnabled(){ return brigComments; }

    static bool     stdInstEnabled(){ return stdSubset; }
    static bool     imgInstEnabled(){ return imgSubset; }
    static bool     gcnInstEnabled(){ return gcnSubset; }
};

// ============================================================================
// ============================================================================
// ============================================================================

class BrigContext : public BrigSettings
{
private:
    BrigContainer       container;
    Brigantine          brigantine;
    DirectiveExecutable currentSbr;      // Last generated executable
    unsigned            labCount;        // Number of autogenerated labels

private:
    BrigContext(const BrigContext&); // non-copyable
    const BrigContext &operator=(const BrigContext &);  // not assignable

public:
    BrigContext() : brigantine(container), labCount(0) { brigantine.startProgram(); }
    ~BrigContext() { brigantine.endProgram(); }

public:
    BrigContainer& getContainer() { return container; }

public: // Directives
    void emitModule();
    void emitExtension(const char* name);

    DirectiveExecutable getCurrentSbr() { return currentSbr; }

    DirectiveExecutable emitSbrStart(unsigned kind, const char* name);
    DirectiveVariable   emitSbrArg(unsigned type, string name, bool isInputArg = true);
    void                startSbrBody();
    void                emitSbrEnd();

    DirectiveLabel emitLabel(const char* name);
    DirectiveLabel emitLabel(const char* name, unsigned idx, unsigned width = 0);
    DirectiveLabel emitAuxLabel();

    void emitComment(string s = "");

public: // Instructions
    void emitRet();
    void emitSt(unsigned type, unsigned segment, Operand from, Operand to, unsigned align = BRIG_ALIGNMENT_1);
    void emitLd(unsigned type, unsigned segment, Operand to, Operand from, unsigned align = BRIG_ALIGNMENT_1);
    void emitMov(unsigned type, Operand to, Operand from);
    void emitAdd(unsigned type, Operand res, Operand op1, Operand op2);
    void emitAdd(unsigned type, Operand res, Operand op1, unsigned n);
    void emitSub(unsigned type, Operand res, Operand op1, Operand op2);
    void emitShl(unsigned type, Operand res, Operand src, unsigned shift);
    void emitShr(unsigned type, Operand res, Operand src, unsigned shift);
    void emitMul(unsigned type, Operand res, Operand op1, unsigned multiplier);
    void emitGetWorkItemId(Operand res, unsigned dim);
    void emitCvt(unsigned dstType, unsigned srcType, OperandRegister to, OperandRegister from);
    void emitLda(OperandRegister dst, DirectiveVariable var);
    void emitLda(OperandRegister dst, OperandAddress addr);
    void emitStoF(OperandRegister dst, OperandRegister src, unsigned segment);
    void emitCmpEq(unsigned cRegIdx, unsigned sRegIdx, unsigned immVal);
    void emitCbr(unsigned cRegIdx, Operand label);
    void emitBr(Operand label);

public: // Operands
    Operand emitReg(OperandRegister reg);
    Operand emitReg(unsigned size, unsigned idx);
    Operand emitVector(unsigned cnt, unsigned type, unsigned idx0);
    Operand emitVector(unsigned cnt, unsigned type, bool isDst = true, unsigned immCnt = 0);
    Operand emitImm(unsigned type, uint64_t lVal = 0, uint64_t hVal = 0);
    Operand emitWavesize();

    Operand emitOperandCodeRef(Code d);

    Operand emitAddrRef(DirectiveVariable var, OperandRegister reg, unsigned offset = 0);
    Operand emitAddrRef(DirectiveVariable var, uint64_t offset = 0);
    Operand emitAddrRef(OperandRegister reg, uint64_t offset = 0);
    Operand emitAddrRef(uint64_t offset, bool is32BitAddr);

    Operand emitLabelAndRef(const char* name);
    Operand emitLabelRef(const char* name);
    Operand emitLabelRef(const char* name, unsigned idx, unsigned width = 0);

    DirectiveVariable emitSymbol(unsigned scalarType, string name, unsigned segment = BRIG_SEGMENT_GLOBAL, unsigned dim = 0)
    {
        assert(name.length() > 0);
        assert(!isArrayType(scalarType));

        DirectiveVariable sym = (dim == 0)? brigantine.addVariable(name, segment, scalarType) :
                                            brigantine.addArrayVariable(name, dim, segment, scalarType);

        sym.modifier().isConst() = false;
        sym.modifier().isDefinition() = true;

        sym.linkage() = (name[0] == '%')? BRIG_LINKAGE_FUNCTION : BRIG_LINKAGE_MODULE;

        sym.allocation() = BRIG_ALLOCATION_AUTOMATIC;
        if      (segment == BRIG_SEGMENT_GLOBAL)   sym.allocation() = BRIG_ALLOCATION_PROGRAM;
        else if (segment == BRIG_SEGMENT_READONLY) sym.allocation() = BRIG_ALLOCATION_AGENT;

        sym.init() = Directive();
        sym.align() = getNaturalAlignment(scalarType);

        return sym;
    }

    OperandConstantBytes emitInitializer(ArbitraryData& values, unsigned arrayElementType)
    {
        return brigantine.createOperandConstantBytes(values.toSRef(), arrayElementType, true);
    }

    DirectiveFbarrier emitFBarrier(const char* name)
    {
        assert(strlen(name) > 0);

        DirectiveFbarrier fb = brigantine.addFbarrier(SRef(name));

        fb.linkage() = (name[0] == '%')? BRIG_LINKAGE_FUNCTION : BRIG_LINKAGE_MODULE;
        fb.modifier().isDefinition() = true;

        return fb;
    }

    unsigned getSegAddrSize(unsigned segment)    { return HSAIL_ASM::getSegAddrSize(segment, isLargeModel()); }
    unsigned getSegAddrType(unsigned segment)    { return (getSegAddrSize(segment) == 32)? BRIG_TYPE_U32 : BRIG_TYPE_U64; }
    unsigned conv2LdStType(unsigned type);

public:
    string getRegName(unsigned size, unsigned idx);
    string getLabName(const char* name, unsigned idx, unsigned width = 0);

};

//=============================================================================
//=============================================================================
//=============================================================================

} // namespace TESTGEN

// ============================================================================

#endif // INCLUDED_HSAIL_TESTGEN_BRIG_CONTEXT_H
