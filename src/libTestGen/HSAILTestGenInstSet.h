//===-- HSAILTestGenInstPropDesc.h - HSAIL Test Generator - Decsription of Instructions ===//
//
//===----------------------------------------------------------------------===//
//
// (C) 2013 AMD Inc. All rights reserved.
//
//===----------------------------------------------------------------------===//

#ifndef INCLUDED_HSAIL_TESTGEN_INST_PROP_DESC_H
#define INCLUDED_HSAIL_TESTGEN_INST_PROP_DESC_H

#include "HSAILValidatorBase.h"
#include "HSAILExtension.h"

using HSAIL_ASM::PropValidator;
using HSAIL_ASM::Extension;
using HSAIL_ASM::isImageInstFormat;

namespace TESTGEN {

//==============================================================================
//==============================================================================
//==============================================================================

enum CategoryId         // Instruction categories
{
    C_MINID = 0,
    C_UNKNOWN = 0,

    C_ARITHMETIC,
    C_MOVE,
    C_ATOMIC_MEMORY,
    C_MEMORY,
    C_IMAGE,
    C_SYNC,
    C_BRANCH,
    C_MISC,

    C_MAXID
};

struct InstCategory
{
    unsigned categoryId;
    unsigned instOpcode;

    bool operator<(const InstCategory& c) const { return this->instOpcode < c.instOpcode; }
};

//==============================================================================
//==============================================================================
//==============================================================================
// Abstract description of an instruction set.
// Subclasses are autogenerated from HDL descriptions.
//
// Each instruction set is either a 'CORE' set or corresponds to an extension such as 'IMAGE'
//
// Each instruction has the following attributes:
// - format
// - category
// - set of properties this instruction supports
// - set of values each property may take
// - set of limitations for property values
//
class InstSet : public PropValidator
{
private:
    const   Extension*     ext;                                 // The extension which corresponds to this set (0 for 'CORE')
    mutable InstCategory*  instCategory;                        // Mapping of opcodes to category (sorted by opcode)

public:
     InstSet(unsigned model, unsigned profile, const Extension* e) : PropValidator(model, profile), ext(e), instCategory(0) {}
     virtual ~InstSet() { delete[] instCategory; }

public:
                                                                // Extension this instruction set belongs to (0 for 'CORE' instruction set)
    virtual const Extension* getExtension() const { return ext;  }

                                                                // Name of this instruction set
    virtual const char*      getName()      const { return ext? ext->getName() : "CORE"; }

public:
                                                                // Return all possible values 'propId' may take
    virtual const unsigned* getPropVals(unsigned propId, unsigned& num) const = 0;

                                                                // Return all opcodes of this instruction set
    virtual const unsigned* getOpcodes(unsigned& num) const = 0;      

                                                                // Return format of specified opcode
    virtual       unsigned  getFormat(unsigned opcode) const = 0;

                                                                // Return all properties which describe specified instruction (primary and secondary)
                                                                // The order of primary properties is important and must be preserved.
                                                                // Primary properties have to be assigned and validated in the specified order.
                                                                // Note that meta-properties are not included in this list because TestGen
                                                                // does not work with these properties _directly_.
    virtual const unsigned* getProps(unsigned opcode, unsigned& prm, unsigned& sec) const = 0;

                                                                // Return all positive values for 'propId' of specified instruction
    virtual const unsigned* getPropVals(unsigned opcode, unsigned propId, unsigned& num) const = 0;

                                                                // Return true if 'propId' has a valid value for instruction 'inst', false otherwise.
                                                                // This function is able to validate each property independently of each other but
                                                                // assumes sertain order of validation. Namely, primary properties must be assigned
                                                                // and validated in the same order as specified by getProps because validation of some
                                                                // properties may include implicit checks of other properties.
                                                                // Note that this validation may be incomplete. Full validation of all necessary
                                                                // conditions for all primary properties is performed only as part of validation for
                                                                // last primary property (this also includes validation of meta-properties).
                                                                // Also note that secondary properties only depend on primary properties.
    virtual bool isValidProp(Inst inst, unsigned propId) const = 0;  

    virtual bool validatePrimaryProps(Inst inst) const = 0;     // Return true if all primary properties have valid values. This is the complete check.

    virtual bool isValidInst(Inst inst) const = 0;              // Return true if instruction has valid values for all props.
                                                                // This function duplicates functionality of InstValidator (used for debugging only).

                                                                // Return true if this instruction set uses 'IMAGE' extension formats
                                                                // (tests for this instruction set must include directive 'extension "IMAGE"')
    virtual bool isImageExt() const
    {
        if (!ext) return false; // CORE

        unsigned num;
        const unsigned* opcodes = getOpcodes(num);
        for (unsigned i = 0; i < num; ++i)
        {
            if (isImageInstFormat(getFormat(opcodes[i]))) return true;
        }
        return false;
    }
                                                                // Returns an array with a mapping between opcodes and categories
    virtual const InstCategory* getCategories(unsigned& num) const = 0;

                                                                // Returns an opcode category
    virtual unsigned getCategory(unsigned opcode) const
    {
        if (!instCategory) initBaseCategoryTab();

        InstCategory sample = {0, opcode};
        unsigned size = getCategoriesNum();
        InstCategory* res = std::lower_bound(instCategory, instCategory + size, sample);

        if (res >= instCategory + size || res->instOpcode != opcode) return C_UNKNOWN;
        if (res->categoryId >= C_MAXID) return C_UNKNOWN;
        return res->categoryId;
    }

private:
    unsigned getCategoriesNum() const
    {
        unsigned size;
        getCategories(size);
        return size;
    }
                                                                // Create a table of categories sorted by opcode
    void initBaseCategoryTab() const
    {
        assert(!instCategory);

        unsigned size;
        const InstCategory* baseCategories = getCategories(size);

        instCategory = new InstCategory[size];
        std::copy(baseCategories, baseCategories + size, instCategory);
        std::sort(instCategory, instCategory + size);
    }
};

//==============================================================================
//==============================================================================
//==============================================================================

}; // namespace TESTGEN

#endif // INCLUDED_HSAIL_TESTGEN_INST_PROP_DESC_H